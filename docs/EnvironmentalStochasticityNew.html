<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Exercise: Environmental Stochasticity</title>

<script src="site_libs/header-attrs-2.16/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/spacelab.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/clipboard-1.7.1/clipboard.min.js"></script>
<link href="site_libs/primer-tooltips-1.4.0/build.css" rel="stylesheet" />
<link href="site_libs/klippy-0.0.0.9500/css/klippy.min.css" rel="stylesheet" />
<script src="site_libs/klippy-0.0.0.9500/js/klippy.min.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Population and community ecology</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Exercises
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="./EnvironmentalStochasticityNew.html">1. Excercise: Environmental Stochasticity</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">




</div>


<script>
  addClassKlippyTo("pre.r, pre.markdown");
  addKlippy('right', 'top', 'auto', '1', 'Copy code', 'Copied!');
</script>
<div id="environmental-stochasticity" class="section level1 tabset">
<h1 class="tabset">Environmental Stochasticity</h1>
<div id="environmental-stochasticity-1" class="section level2">
<h2>Environmental stochasticity</h2>
<p>In the lecture, we derived</p>
<p><span class="math display">\[
N(t)=N(0)*(1+\beta-\delta)^t=N(0)*\lambda^t
\]</span> as a model for exponential growth in discrete time, where <span class="math inline">\(\lambda = 1 + \beta - \delta\)</span>. <!--If the population size is sufficiently large, this becomes a deterministic model because the number of offspring produced, *B*, and the number of individuals dying, *D*, at any time step will be very close to the expected values $N(t)\beta$ and $N(t)\delta$, respectively. This is due to the [law of large numbers](https://en.wikipedia.org/wiki/Law_of_large_numbers). We will investigate the effect of *demographic stochasticity* as it occurs in small populations in a later exercise.--> Importantly, the above equation assumes that the growth factor <span class="math inline">\(\lambda\)</span> does not vary in time. In this exercise, we will relax this assumption. For example, climatic conditions vary among years and this might affect the average number of offspring, <span class="math inline">\(\beta\)</span>, and the probability to die, <span class="math inline">\(\delta\)</span>, of ALL individuals in a population. In short, <span class="math inline">\(\lambda\)</span> will vary in time and we indicate this by adding <span class="math inline">\(t\)</span> as an argument, <span class="math inline">\(\lambda(t)\)</span>.</p>
<p>In this exercise, we simulate environmental stochasticity in <em>R</em>. We do this for the simplest possible case, namely, that <span class="math inline">\(\lambda(t)\)</span> can take one of two different values: <span class="math display">\[
\lambda_1 = \bar \lambda + \epsilon\\
\lambda_2 = \bar \lambda - \epsilon
\]</span> For simplicity, let us furthermore assume that each environment occurs with equal probability. We can do this in <em>R</em> by using the function <code>sample(x = possible_outcomes, size = tmax, prob = probabilities, replace = TRUE)</code>:</p>
<pre class="r"><code>lambda_mean &lt;- 1.01
deviation &lt;- 0.2
possible_outcomes &lt;- c(lambda_mean - deviation, lambda_mean + deviation)
probabilities &lt;- c(0.5, 0.5)
N0 &lt;- 10 # initial population size
tmax &lt;- 200 # length of the time series

sample(x = possible_outcomes, size = tmax, prob = probabilities, replace = TRUE) # produces a vector of tmax random numbers taking the value 0.51  1.51</code></pre>
<p>In the next step, we want to use the sequence of <span class="math inline">\(\lambda\)</span>-values to project a population that consists of <em>N0</em> individuals at time <em>t=0</em> <em>t</em> time steps into the future. Thus, we want to compute</p>
<p><span class="math display">\[
N(t)=\lambda(t-1)*\lambda(t-2)*\ldots*\lambda(2)*\lambda(1)*\lambda(0)*N(0).
\]</span></p>
<p>In the following, we define a function that produces a stochastic time series.</p>
<pre class="r"><code>environmental_stochasticity &lt;- function(N0, tmax, possible_outcomes, probabilities) {
  growth_factors &lt;- sample(possible_outcomes, tmax, probabilities, replace = TRUE)
  time_series &lt;- c()
  time_series[1] &lt;- N0
  for (t in 1:tmax) {
    time_series[t+1] &lt;- time_series[t]*growth_factors[t]
  }
  return(time_series)
}</code></pre>
<p>We can also introduce an <em>extinction threshold</em>. If the population size drops below this threshold, then the population is extinct and cannot recover. A natural choice for such a threshold is 1.</p>
<pre class="r"><code>environmental_stochasticity_ext &lt;- function(N0, tmax, possible_outcomes, probabilities) {
  growth_factors &lt;- sample(possible_outcomes, tmax, probabilities, replace = TRUE)
  time_series &lt;- c()
  time_series[1] &lt;- N0
  for (t in 1:tmax) {
    time_series[t+1] &lt;- ifelse(time_series[t]*growth_factors[t] &lt; 1, 0, time_series[t]*growth_factors[t]) # sets the population vector to 0 in case N drops below 1
  }
  return(time_series)
}</code></pre>
<p>Next, we plot the resulting time series.</p>
<pre class="r"><code>time_series &lt;- environmental_stochasticity(N0, tmax, possible_outcomes, probabilities) # runs the function

plot(time_series, type=&quot;l&quot;, xlab=&quot;time&quot;, ylab=&quot;population size&quot;)</code></pre>
<p>Alternatively, we can also plot the time series on a log-scale by taking the natural logarithm of population size.</p>
<pre class="r"><code>plot(log(time_series + 1), type=&quot;l&quot;, xlab=&quot;time&quot;, ylab=&quot;ln(population size)&quot;)</code></pre>
<p>Note that for the log-scale we add 1 to all entries in the time series. The reason is that <span class="math inline">\(\ln(N)\)</span> for <span class="math inline">\(N&lt;1\)</span> is negative.</p>
<p>At each instance this code is executed (starting from the line in which the vector <em>growth_factors</em> is defined), we obtain a different random time series. If you produce several time series, you will note that in some cases the population goes extinct while in others the population is still present after <em>tmax</em> time steps.</p>
<!--
To confirm that the arithmetic mean of the annual grwoth factors, given by

$$
\bar\lambda=\frac{1}{t}(\lambda_{t-1}+\lambda_{t-2}+\ldots+\lambda_2+\lambda_1+\lambda_0),
$$

is not informative, we can add the time series as it would result if the population would grow each time according to the factor $\bar\lambda$.


```r
arithmetic_mean <- mean(growth_factors) # calculates the arithmetic mean of the annual grwoth factors
arithmetic_mean # shows the value of the arithmetic mean
```

Next, we add the line that shows how the population develops if it changes each year according to the arithmetic mean of the $\bar\lambda$.


```r
time_series_arith <- c() # creates an empty vector in which we will store the population time series
time_series_arith[1] <- N0 # first entry in this vector equals initial population size N(0)
  for (t in 1:n) {# for-loop that projects the population n time steps into the future using only the arithmetric mean
  time_series_arith[t+1] <- max(0, time_series_arith[t]*arithmetic_mean)
  }

plot(0:n, time_series+1, type="l", log="y", ylim=c(1,max(time_series)), xlab="time", ylab="population size") # repeats the plot with the stochastic time series
lines(0:n, time_series_arith, type="p", col="2") # adds the line based on arithmetric mean to the plot
```

As expected, the arithmetic mean growth factor is not very accurate in predicting the fate of the population.
-->
<p>Next, let us add a line that shows how the population changes if each year it grows according to the arithmetic mean growth factor <span class="math inline">\(\bar\lambda\)</span>.</p>
<!--
$$
\tilde\lambda:=(\lambda_{t-1}*\lambda_{t-2}*\ldots*\lambda_2*\lambda_1*\lambda_0)^{\frac{1}{t}}
$$

```r
geometric_mean <- exp(mean(log(growth_factors))) # calculates the geometric mean of the annual growth factors (can you derive the formula that is used here?) 
geometric_mean # shows the value of the geometric mean
```
-->
<p>The following piece of code adds the desired line, both on the natural and log-scale</p>
<pre class="r"><code>time_series_geom &lt;- c()
time_series_geom[1] &lt;- N0
for (t in 1:tmax) {
  time_series_geom[t+1] &lt;- time_series_geom[t]*lambda_mean
}

# plots on natural scale
plot(time_series, type=&quot;l&quot;, ylim=c(0, max(time_series, time_series_geom)), xlab=&quot;time&quot;, ylab=&quot;population size&quot;)
lines(time_series_geom, type=&quot;l&quot;, col=&quot;Red&quot;)

# plots on log-scale
plot(log(time_series +1), type=&quot;l&quot;, ylim=c(0, log(max(time_series, time_series_geom))), xlab=&quot;time&quot;, ylab=&quot;ln(population size)&quot;)
lines(log(time_series_geom + 1), type=&quot;l&quot;, col=&quot;Red&quot;)</code></pre>
<p>You might encounter simulation runs in which the population goes extinct while the projection based on the geometric mean suggests that the population should slowly increase. Can you explain this apparent contradiction?</p>
</div>
<div id="the-probability-of-extinction" class="section level2">
<h2>The probability of extinction</h2>
<p>You have seen that for the chosen set of parameters <span class="math inline">\(\bar \lambda\)</span> and <span class="math inline">\(\epsilon\)</span> a certain proportion of simulation runs results in extinction. How does the probability of extinction depend on these parameters? Let us explore this question by changing the value of <span class="math inline">\(\epsilon\)</span>.</p>
<p>To investigate this question more systematically, it is useful to automatize the process in <em>R</em>, so that we can produce many time series in one step. For this part, we use the function with the extinction threshold and plot the time series on a log scale.</p>
<p>Specifically, the next piece of code allows us to execute the population simulation several times by putting our function inside a <em>for</em>-loop. How often the times series is repeated is determined by the new parameter <em>sim</em>, below set equal to 10. Note that each time series is different from the others because it is based on a different set of random <span class="math inline">\(\lambda\)</span>-values.</p>
<pre class="r"><code>sim &lt;- 10 # number of simulation runs

results &lt;- matrix(nrow = tmax + 1, ncol = sim) # creates an empty matrix with n+1 rows and sim columns in which we will store the time series

for (i in 1:sim) {# executes the function sim times
  results[, i] &lt;- environmental_stochasticity_ext(N0, tmax, possible_outcomes, probabilities) # produces a time series and stores it in the jth column of the matrix results
}</code></pre>
<p>Let us combine all time series into a single plot.</p>
<pre class="r"><code>cl &lt;- rainbow(sim) # set number of colors equal to number of simulations

plot(log(results[, 1] + 1), type=&quot;l&quot;, ylim=c(0, log(max(time_series_geom, results))), col=cl[1], xlab=&quot;time&quot;, ylab=&quot;ln(population size)&quot;) # plot the result from the first simulation
for (i in 2:sim) {# add the results from all other simulations to the same graph
  lines(log(results[, i] + 1), type=&quot;l&quot;, col=cl[i])
}
lines(log(time_series_geom + 1), type=&quot;l&quot;, col=&quot;4&quot;)</code></pre>
<pre class="r"><code>log_row_means &lt;- rowMeans(log(results + 1))

# we can add mean of all time series to the previous graph
lines(log_row_means, type=&quot;l&quot;, col=&quot;Black&quot;)</code></pre>
<p>For the environmental variation investigated here (with only two possible environments), one can show that the mean over many trajectories is given by</p>
<p><span class="math display">\[
\begin{equation}
\bar N(t) = N_0 \exp(\bar r t),
\end{equation}
\]</span> where</p>
<p><span class="math display">\[
\begin{equation}\label{eq:bar_r}
\bar r = \ln \bar\lambda + \frac{1}{2} \ln \left(1 - \frac{\epsilon^2}{\bar\lambda^2}\right).
\end{equation}
\]</span> Let us add a line showing <span class="math inline">\(\bar N(t)\)</span> according to this formula to our plots.</p>
<pre class="r"><code>exp_mean_lambda &lt;- exp(log(lambda_mean) + 1/2*log(1 - deviation^2 / lambda_mean^2)) # exponential of the formula in the above equation

time_series_expected &lt;- c()
time_series_expected[1] &lt;- N0
for (t in 1:tmax) {
  time_series_expected[t+1] &lt;- time_series_expected[t]*exp_mean_lambda
}

# we can add the expected mean time series to the previous graph
lines(log(time_series_expected + 1), type=&quot;l&quot;, col=&quot;Gray&quot;)</code></pre>
<div id="tasks" class="section level3">
<h3>TASKS</h3>
<p>From our graphs, one can determine the number of simulation runs in which the population goes extinct, simply by counting the number of simulations that hit zero.</p>
<ol style="list-style-type: decimal">
<li><p>In your latest plot, you have combined four types of line: (i) simulated stochastic time series, (ii) the mean over these simulated time series, (iii) the mathematically calculated <em>expected</em> mean trajectory, and (iv) the trajectory predicted by the arithmetic mean growth factor <span class="math inline">\(\bar\lambda\)</span>. Summerize what you learned from these graphs. What is the effect of environmental stochasticity on population growth and population survival?</p></li>
<li><p>Investigate the magnitude of environmental fluctuations in more detail by varying the amplitude of the environmental fluctuations. Keep <span class="math inline">\(\bar \lambda = 1.01\)</span> fixed and vary <span class="math inline">\(\epsilon\)</span>, the deviation in <span class="math inline">\(\lambda\)</span>, according to <span class="math inline">\(\epsilon = (0; 0.05; 0.1; 0.15; 0.2)\)</span>. For each value of <span class="math inline">\(\epsilon\)</span> report the number of simulations that result in extinction based on <strong>20</strong> simulation runs. Run you simulations for at least <strong>300</strong> time steps. For which value of <span class="math inline">\(\epsilon\)</span> does the expected mean trajectory starts to decline?</p></li>
<li><p>Submit your results.</p></li>
</ol>
</div>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
