<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Exercise: Environmental Stochasticity</title>

<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/spacelab.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/clipboard-1.7.1/clipboard.min.js"></script>
<link href="site_libs/primer-tooltips-1.4.0/build.css" rel="stylesheet" />
<link href="site_libs/klippy-0.0.0.9500/css/klippy.min.css" rel="stylesheet" />
<script src="site_libs/klippy-0.0.0.9500/js/klippy.min.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Population and community ecology</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Exercises
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="./EnvironmentalStochasticity.html">1. Excercise: Environmental Stochasticity</a>
    </li>
    <li>
      <a href="./DemographicStochasticity.html">2. Excercise: Demograhic Stochasticity</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">




</div>


<script>
  addClassKlippyTo("pre.r, pre.markdown");
  addKlippy('right', 'top', 'auto', '1', 'Copy code', 'Copied!');
</script>
<div id="environmental-stochasticity" class="section level1 tabset">
<h1>Environmental Stochasticity</h1>
<div id="environmental-stochasticity-1" class="section level2">
<h2>Environmental stochasticity</h2>
<p>In the lecture, we derived</p>
<p><span class="math display">\[
N(t)=N(0)*(1+\beta-\delta)^t=N(0)*\lambda^t
\]</span> as a model for exponential growth in discrete time, where <span class="math inline">\(\lambda = 1 + \beta - \delta\)</span>. If the population size is sufficiently large, this becomes a deterministic model because the number of offspring produced, <em>B</em>, and the number of individuals dying, <em>D</em>, at any time step will be very close to the expected values <span class="math inline">\(N(t)\beta\)</span> and <span class="math inline">\(N(t)\delta\)</span>, respectively. This is due to the <a href="https://en.wikipedia.org/wiki/Law_of_large_numbers">law of large numbers</a>. We will investigate the effect of <em>demographic stochasticity</em> as it occurs in small populations in a later exercise.</p>
<p>Importantly, the above equation assumes that the growth factor <span class="math inline">\(\lambda\)</span> does not vary in time. In this exercise, we will relax this assumption. For example, climatic conditions vary among years and this might affect the average number of offspring, <span class="math inline">\(\beta\)</span>, and the probability to die, <span class="math inline">\(\delta\)</span>, of ALL individuals in a population. In short, <span class="math inline">\(\lambda\)</span> will vary in time and we indicate this by giving it a subscript, <span class="math inline">\(\lambda_t\)</span>.</p>
<p>In this exercise, we simulate environmental stochasticity in R. We do this by choosing a set of random postive numbers that represent the <span class="math inline">\(\lambda\)</span>-values in different years. More concretely, let us assume that we can represent the fluctuation in the environment by drawing a sequence of <span class="math inline">\(\lambda\)</span>-values from an interval with a lower boundary given by the parameter <em>min</em> and an upper boundary given by the parameter <em>max</em>. Let us furthermore assume that each number within the interval <em>(min, max)</em> occurs with equal probability. We can do this in <em>R</em> by using the command <code>runif(n, min,max)</code>. The name runif is an abbreviation combining the words <em>random</em> and <em>uniform</em>, indicating that the command <code>runif(n, min, max)</code> produces a vecotor of <em>`max</em> numbers (the length of the time series) and that these are drawn randomly from the interval <em>(min, max)</em>.</p>
<pre class="r"><code>runif(10, 1, 2) # produces a vector of 10 random numbers between 1 and 2</code></pre>
<p>We could in principle decide to draw the random numbers from distributions other than the uniform distribution, for example from a Poisson distribution, using the command <code>rpois(n, lambda)</code>.</p>
<p>Let us define the parameter values of the random distribution and then draw the sequence of <span class="math inline">\(\lambda\)</span>-values.</p>
<pre class="r"><code>n &lt;- 100 # lenght of time series
min &lt;- 0.5 # lowest possible value of the growth factor lamabda
max &lt;- 2 # largest possible value of the growth factor lambda

growth_factors &lt;- runif(n, min, max)</code></pre>
<p>In the next step, we want to use the sequence of <span class="math inline">\(\lambda\)</span>-values to project a population that consists of <em>N0</em> individuals at time <em>t=0</em> <em>t</em> time steps into the future. Thus, we want to compute</p>
<p><span class="math display">\[
N(t)=\lambda_{t-1}*\lambda_{t-2}*\ldots*\lambda_2*\lambda_1*\lambda_0*N(0).
\]</span></p>
<pre class="r"><code>N0 &lt;- 10 # population size at time t=0
time_series &lt;- c() # creates an empty vector in which we will store the population time series
time_series[1] &lt;- N0 # initial population size N0 entered as first entry

for (t in 1:n) {# for-loop that projects the population n time steps into the future
  time_series[t+1] &lt;- if (time_series[t]*growth_factors[t] &lt; 1) 0 # sets the population vector to 0 in case N drops below 1
  else time_series[t]*growth_factors[t]
  }</code></pre>
<p>Assuming that <em>N</em> describes the <em>absolute population size</em> we in this code set any population size less than one equal to zero (half a fox does not exist). In other words, if <span class="math inline">\(N &lt; 1\)</span> at any time <em>t</em>, then the we consider the population extinct from that time point onwards. Next, we plot the resulting time series on a log-scale.</p>
<pre class="r"><code>plot(0:n, time_series+1, type=&quot;l&quot;, log=&quot;y&quot;, ylim=c(1,max(time_series)), xlab=&quot;time&quot;, ylab=&quot;population size&quot;) # Note that we add 1 to all entries in the time series. The reason is that ln(0) is not defined.</code></pre>
<p>At each instance this code is executed (starting from the line in which the vector <code>growht_factors</code> is defined), we obtain a different random time series. If you produce several time series, you will note that in some cases the population goes extinct while in others the population is still present after <em>n</em> time steps.</p>
<p>To confirm that the arithmetic mean of the annual grwoth factors, given by</p>
<p><span class="math display">\[
\bar\lambda=\frac{1}{t}(\lambda_{t-1}+\lambda_{t-2}+\ldots+\lambda_2+\lambda_1+\lambda_0),
\]</span></p>
<p>is not informative, we can add the time series as it would result if the population would grow each time according to the factor <span class="math inline">\(\bar\lambda\)</span>.</p>
<pre class="r"><code>arithmetic_mean &lt;- mean(growth_factors) # calculates the arithmetic mean of the annual grwoth factors
arithmetic_mean # shows the value of the arithmetic mean</code></pre>
<p>Next, we add the line that shows how the population develops if it changes each year according to the arithmetic mean of the <span class="math inline">\(\bar\lambda\)</span>.</p>
<pre class="r"><code>time_series_arith &lt;- c() # creates an empty vector in which we will store the population time series
time_series_arith[1] &lt;- N0 # first entry in this vector equals initial population size N(0)
  for (t in 1:n) {# for-loop that projects the population n time steps into the future using only the arithmetric mean
  time_series_arith[t+1] &lt;- max(0, time_series_arith[t]*arithmetic_mean)
  }

plot(0:n, time_series+1, type=&quot;l&quot;, log=&quot;y&quot;, ylim=c(1,max(time_series)), xlab=&quot;time&quot;, ylab=&quot;population size&quot;) # repeats the plot with the stochastic time series
lines(0:n, time_series_arith, type=&quot;p&quot;, col=&quot;2&quot;) # adds the line based on arithmetric mean to the plot</code></pre>
<p>As expected, the arithmetic mean growth factor is not very accurate in predicting the fate of the population.</p>
<p>Next, let us add a line that shows how the population changes if each year it grows according to the geometric mean, <span class="math inline">\(\tilde\lambda\)</span>, of the annual growth factors, defined as</p>
<p><span class="math display">\[
\tilde\lambda:=(\lambda_{t-1}*\lambda_{t-2}*\ldots*\lambda_2*\lambda_1*\lambda_0)^{\frac{1}{t}}
\]</span></p>
<pre class="r"><code>geometric_mean &lt;- exp(mean(log(growth_factors))) # calculates the geometric mean of the annual grwoth factors by using Eq.(3.16) in Pasztor et al. (2016)
geometric_mean # shows the value of the geometric mean</code></pre>
<p>The following piece of code adds the desired line:</p>
<pre class="r"><code>time_series_geom &lt;- c()
time_series_geom[1] &lt;- N0
for (t in 1:n) {
  time_series_geom[t+1] &lt;- max(0,time_series_geom[t]*geometric_mean)
}

plot(0:n, time_series+1, type=&quot;l&quot;, log=&quot;y&quot;, ylim=c(1,max(time_series)), xlab=&quot;time&quot;, ylab=&quot;population size&quot;) # repeats the plot with the stochastic time series
lines(0:n, time_series_arith, type=&quot;p&quot;, col=&quot;2&quot;) # adds the line based on arithmetric mean in red
lines(0:n, time_series_geom, type=&quot;p&quot;, col=&quot;4&quot;) # add the line based on geometric mean in blue</code></pre>
<p>You might encounter simulation runs in which the population goes extinct while the projection based on the geometric mean suggests that the population should slowly increase. Can you explain this apparent contradiction?</p>
</div>
<div id="the-probability-of-extinction" class="section level2">
<h2>The probability of extinction</h2>
<p>You have seen that for the chosen set of parameters *min**, <em>max</em>, <em>n</em> and <em>N0</em> a certain proportion of simulation runs results in extinction. How does the probability of extinction depend on these parameters? You can explore this question by changing the values for <em>min</em>, <em>max</em>, <em>n</em> and <em>N0</em>.</p>
<p>To investigate this question more systematically, it is useful to automatize the process in <em>R</em>. We start by defining a new function to make the depency of the time series on <em>min</em>, <em>max</em>, <em>n</em> and <em>N0</em> explicit.</p>
<pre class="r"><code>environmental_stochasticity &lt;- function(N0, n, min, max) {# function with four arguments
  growth_factors &lt;- runif(n, min, max)
  time_series &lt;- c()
  time_series[1] &lt;- N0
  for (t in 1:n) {
    time_series[t+1] &lt;- if (time_series[t]*growth_factors[t] &lt; 1) 0 else time_series[t]*growth_factors[t]
  }
  return(time_series)
}</code></pre>
<p>This function produces a population time series for a given set of parameters. The resulting population time series is stored in the vector <em>time_series</em>.</p>
<p>The next piece of code allows us to execute the population simulation several times by putting our function inside a for-loop. How often the times series is repeated is determined by the new parameter <em>sim</em>, below set equal to 20. Note that each time series is different from the others because it is based on a different set of random <span class="math inline">\(\lambda\)</span>-values.</p>
<pre class="r"><code>n &lt;- 500 # lenght of time series
min &lt;- 0.9 # lowest possible value for growth factor
max &lt;- 1.1 # largest possible value of growth factor
N0 &lt;- 10 # initial population size
sim &lt;- 20 # number of simulation runs

results &lt;- matrix(nrow = n + 1, ncol = sim) # creates an empty matrix with n+1 rows and sim columns in which we will store the time series

j &lt;- 1 # intialize a counter
for (i in 1:sim) {# executes the function sim times
  results[, j] &lt;- environmental_stochasticity(N0, n, min, max) # produces a time series and stores it in the jth column of the matrix results
  j = j + 1 # updates the counter by increasing it by 1
}</code></pre>
<p>The following code plots all time series on a log scale in a single figure:</p>
<pre class="r"><code>cl &lt;- rainbow(sim) # set number of colors equal to number of simulations

maxN &lt;- numeric(sim) # here we determines how long the y-axis has to be
for (i in 1:sim) {# we do this by determining the largest population size that is reached in each of the simulations
  maxN[i] &lt;- max(results[, i])
}

plot(0:n, results[, 1]+1, type=&quot;l&quot;, log=&quot;y&quot;, ylim=c(1, max(maxN)), col=cl[1], xlab=&quot;time&quot;, ylab=&quot;population size&quot;) # plot the result from the first simulation
for (i in 2:sim) {# add the results from all other simulations to the same graph
  lines(0:n, results[, i]+1, type=&quot;l&quot;, col=cl[i])
}</code></pre>
<p>From these graphs, you can determine the number of simulation runs in which the population goes extinct.</p>
<div id="tasks" class="section level3">
<h3>TASKS</h3>
<ol style="list-style-type: decimal">
<li><p>Keep <em>max=2</em> fixed and vary <em>min</em> and <em>n</em> according to <em>min = (0; 0.1; 0.2; 0.3; 0.4; 0.5)</em> and <em>n = (100; 200; 500)</em>, respectively. Varying both parameters together gives you 18 parameter combinations which you can arrange in a table with three rows (<em>n</em>) and six columns (<em>min</em>). In each cell of this table, enter the proportion of 20 runs that result in extinction. Do these simulations for <em>n=500</em>, of if this takes too long, for <em>n=200</em>.</p></li>
<li><p>Keep <em>n=500</em> fixed and vary <em>min</em> and <em>max</em> according to <em>min/max = (0.9/1.1; 0.8/1.2; 0.7/1.3; 0.5/1.5; 0.2/1.8)</em>. For each <em>min/max</em> report the proportion of 20 runs in which the population goes extinct.</p></li>
<li><p>For <em>n=500</em> and a pair of <em>min</em> and <em>max</em> of your own choice explore the effect of <em>N(0)</em> by varying it according to <em>N0=(1; 2; 3; 5; 10; 50)</em>. For each value of <em>N(0)</em>, report the proportion of ten runs in which the population went extinct.</p></li>
</ol>
<p>For each exercise, clarify for yourself why the observed pattern makes sense. Submit your results (for example, by entering them into a data frame).</p>
</div>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
